{
  "author": "Arthur Pacaud (arthuro555)",
  "category": "Advanced",
  "extensionNamespace": "",
  "gdevelopVersion": ">=5.5.222",
  "fullName": "Sprite Snapshot",
  "helpPath": "",
  "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0ibWRpLWNhbWVyYS1lbmhhbmNlIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTksM0w3LjE3LDVINEEyLDIgMCAwLDAgMiw3VjE5QTIsMiAwIDAsMCA0LDIxSDIwQTIsMiAwIDAsMCAyMiwxOVY3QTIsMiAwIDAsMCAyMCw1SDE2LjgzTDE1LDNNMTIsMThBNSw1IDAgMCwxIDcsMTNBNSw1IDAgMCwxIDEyLDhBNSw1IDAgMCwxIDE3LDEzQTUsNSAwIDAsMSAxMiwxOE0xMiwxN0wxMy4yNSwxNC4yNUwxNiwxM0wxMy4yNSwxMS43NUwxMiw5TDEwLjc1LDExLjc1TDgsMTNMMTAuNzUsMTQuMjUiIC8+PC9zdmc+",
  "name": "RenderToSprite",
  "previewIconUrl": "https://resources.gdevelop-app.com/assets/Icons/camera-enhance.svg",
  "shortDescription": "Renders an object, layer, scene or an area of a scene and puts the resulting image into a sprite.",
  "version": "0.0.6",
  "description": [
    "Allows rendering (creating an image) of objects, layers and the scene to display in a sprite. ",
    "This allows to make optimizations by transforming the resulting image of a shape painter into a faster sprite, or to make viewports/cameras."
  ],
  "origin": {
    "identifier": "RenderToSprite",
    "name": "gdevelop-extension-store"
  },
  "tags": [
    "experimental",
    "non-public apis",
    "visual",
    "sprite",
    "viewport",
    "camera",
    "render",
    "texture",
    "pixijs",
    "snapshot"
  ],
  "authorIds": [
    "ZgrsWuRTAkXgeuPV9bo0zuEcA2w1",
    "PEzPAaWHgYgk5UwIPppsL6f2ugp2",
    "nrasHJ5nmnWucadlqzx0EctTKZ73"
  ],
  "dependencies": [],
  "globalVariables": [],
  "sceneVariables": [],
  "eventsFunctions": [
    {
      "fullName": "",
      "functionType": "Action",
      "name": "onFirstSceneLoaded",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "gdjs._renderToSprite = {};",
            "gdjs._renderToSprite.rt = PIXI.RenderTexture.create({ width: 100, height: 100 });",
            "gdjs._renderToSprite.sprite = PIXI.Sprite.from(gdjs._renderToSprite.rt);",
            "gdjs._renderToSprite.snapshotCanvas = document.createElement('canvas');",
            "gdjs._renderToSprite.snapshotThreeRenderer = new THREE.WebGLRenderer({",
            "    canvas: gdjs._renderToSprite.snapshotCanvas,",
            "    antialias:",
            "        runtimeScene.getGame().getAntialiasingMode() !== 'none' &&",
            "        (runtimeScene.getGame().isAntialisingEnabledOnMobile() || !gdjs.evtTools.common.isMobile())",
            "});",
            "gdjs._renderToSprite.snapshotThreeRenderer.autoClear = false;",
            "gdjs._renderToSprite.snapshotThreeRenderer.setSize(100, 100);",
            "gdjs._renderToSprite.snapshotPixiRenderer = new PIXI.Renderer({",
            "    width: 100,",
            "    height: 100,",
            "    view: gdjs._renderToSprite.snapshotCanvas,",
            "    // @ts-ignore - reuse the context from Three.js.",
            "    context: gdjs._renderToSprite.snapshotThreeRenderer.getContext(),",
            "    clearBeforeRender: false,",
            "    preserveDrawingBuffer: true,",
            "    antialias: false,",
            "    backgroundAlpha: 0",
            "});",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [],
      "objectGroups": []
    },
    {
      "description": "Renders an object and puts the rendered image into a sprite object.",
      "fullName": "Render an object into a sprite",
      "functionType": "Action",
      "name": "RenderObject",
      "sentence": "Render _PARAM1_ into sprite _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const source = eventsFunctionContext.getObjects(\"source\")[0].getRendererObject();",
            "const renderTarget = eventsFunctionContext.getObjects(\"renderTarget\")[0].getRendererObject();",
            "",
            "// Reset position so that it is not offscreen while rendering",
            "const { x: originalX, y: originalY } = source.position;",
            "const { width, height, x, y } = source.getLocalBounds();",
            "source.position = { x: -x, y: -y };",
            "",
            "// Ensure the target is a RenderTexture of the correct size",
            "if (renderTarget.texture instanceof PIXI.RenderTexture) {",
            "    renderTarget.texture.resize(width, height);",
            "} else {",
            "    renderTarget.texture = PIXI.RenderTexture.create({",
            "        width,",
            "        height,",
            "        scaleMode: runtimeScene.getGame().getScaleMode() === \"linear\"",
            "            ? PIXI.SCALE_MODES.LINEAR",
            "            : PIXI.SCALE_MODES.NEAREST",
            "    });",
            "}",
            "",
            "// Render ðŸ˜Ž",
            "runtimeScene",
            "    .getGame()",
            "    .getRenderer()",
            "    .getPIXIRenderer()",
            "    .render(source, { renderTexture: renderTarget.texture });",
            "",
            "// Restore original position",
            "source.position = { x: originalX, y: originalY };",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "The object to render",
          "name": "source",
          "type": "objectList"
        },
        {
          "description": "The sprite to render to",
          "name": "renderTarget",
          "supplementaryInformation": "Sprite",
          "type": "objectList"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Renders a layer and puts the rendered image into a sprite object.",
      "fullName": "Render a layer into a sprite",
      "functionType": "Action",
      "name": "RenderLayer",
      "sentence": "Render layer _PARAM1_ into sprite _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const layer = runtimeScene.getLayer(eventsFunctionContext.getArgument(\"layer\"));",
            "const layerCameraZoom = layer.getCameraZoom();",
            "const layerRenderer = layer.getRenderer(); //LayerPixiRenderer",
            "const layerHas2DObjects = layerRenderer.has2DObjects();",
            "const layerHas3DObjects = layerRenderer.has3DObjects();",
            "const threeScene = layerRenderer.getThreeScene();",
            "const threeCamera = layerRenderer.getThreeCamera();",
            "const threeComposer = layerRenderer.getThreeEffectComposer();",
            "const is3d = layerHas3DObjects && threeScene && threeCamera;",
            "",
            "const pixiRenderer = runtimeScene.getGame().getRenderer().getPIXIRenderer();",
            "",
            "/** @type {gdjs.SpriteRuntimeObject} */",
            "const obj = objects[0];",
            "",
            "/** @type {PIXI.Sprite} */",
            "const renderTarget = obj.getRendererObject();",
            "",
            "let height = runtimeScene.getLayer(\"\").getCameraHeight();",
            "let width = runtimeScene.getLayer(\"\").getCameraWidth();",
            "",
            "if (runtimeScene.getLayer(\"\").getCameraZ() !== 0) { // Changing the 'z' value of the camera impacts the zoom factor",
            "    height = height * layerCameraZoom;",
            "    width = width * layerCameraZoom;",
            "}",
            "",
            "height = Math.floor(height);",
            "width = Math.floor(width);",
            "",
            "// Prepare for render",
            "runtimeScene._updateLayersPreRender();",
            "runtimeScene._updateObjectsPreRender();",
            "",
            "// Ensure the target is a RenderTexture of the correct size",
            "gdjs._renderToSprite.rt.resize(width, height);",
            "if (renderTarget.texture instanceof PIXI.RenderTexture) {",
            "    renderTarget.texture.resize(width, height);",
            "} else {",
            "    renderTarget.texture = PIXI.RenderTexture.create({",
            "        width,",
            "        height,",
            "        scaleMode: runtimeScene.getGame().getScaleMode() === \"linear\"",
            "            ? PIXI.SCALE_MODES.LINEAR",
            "            : PIXI.SCALE_MODES.NEAREST",
            "    });",
            "}",
            "",
            "if (is3d) {",
            "",
            "    let lastRenderWas3D = true;",
            "    const layerRenderingType = layer.getRenderingType();",
            "    ",
            "    gdjs._renderToSprite.snapshotThreeRenderer.setSize(width, height);",
            "    gdjs._renderToSprite.snapshotPixiRenderer.resize(width, height);",
            "        ",
            "    // TODO (3D) - optimization: do this at the beginning for all layers that are 2d+3d?",
            "    // So the second pass is clearer (just rendering 2d or 3d layers without doing PixiJS renders in between).",
            "    ",
            "    if (layerRenderingType === gdjs.RuntimeLayerRenderingType.TWO_D_PLUS_THREE_D) {",
            "        ",
            "        if (layerHas2DObjects) {",
            "        ",
            "            gdjs._renderToSprite.snapshotThreeRenderer.resetState();",
            "            gdjs._renderToSprite.snapshotPixiRenderer.reset();",
            "",
            "            // Do the rendering of the PixiJS objects of the layer on the render texture.",
            "            // Then, update the texture of the plane showing the PixiJS rendering,",
            "            // so that the 2D rendering made by PixiJS can be shown in the 3D world.",
            "            layerRenderer.renderOnPixiRenderTexture(gdjs._renderToSprite.snapshotPixiRenderer);",
            "            layerRenderer.updateThreePlaneTextureFromPixiRenderTexture(gdjs._renderToSprite.snapshotThreeRenderer, gdjs._renderToSprite.snapshotPixiRenderer);",
            "            lastRenderWas3D = false;",
            "        }",
            "        ",
            "        layerRenderer.show2DRenderingPlane(layerHas2DObjects);",
            "    }",
            "",
            "    if (!lastRenderWas3D) {",
            "        //It's important to reset the internal WebGL state of PixiJS, then Three.js",
            "        // to ensure the 3D rendering is made properly by Three.js",
            "        gdjs._renderToSprite.snapshotPixiRenderer.reset();",
            "        gdjs._renderToSprite.snapshotThreeRenderer.resetState();",
            "    }",
            "    ",
            "    // Render the background color.",
            "    gdjs._renderToSprite.snapshotThreeRenderer.setClearColor(runtimeScene.getBackgroundColor());",
            "    gdjs._renderToSprite.snapshotThreeRenderer.resetState();",
            "    if (runtimeScene.getClearCanvas()) gdjs._renderToSprite.snapshotThreeRenderer.clear();",
            "    threeScene.background = new THREE.Color(runtimeScene.getBackgroundColor());",
            "",
            "    // Clear the depth as each layer is independent and display on top of the previous one, even 3D objects.",
            "    // SEE: RuntimeScenePixiRenderer",
            "    gdjs._renderToSprite.snapshotThreeRenderer.clearDepth();",
            "    if (layerRenderer.hasPostProcessingPass() && 'renderer' in threeComposer) {",
            "        //If there are any post processing effects, fake out the Effect Composer",
            "        //by temporarily setting its renderer to the snapshotThreeRenderer, so that",
            "        //the snapshot includes those effects.",
            "        const originalRenderer = threeComposer.renderer;",
            "        threeComposer.renderer = gdjs._renderToSprite.snapshotThreeRenderer;",
            "        threeComposer.render();",
            "        threeComposer.renderer = originalRenderer;",
            "    } else {",
            "        gdjs._renderToSprite.snapshotThreeRenderer.render(threeScene, threeCamera);",
            "    }",
            "    ",
            "    // Prerender to a temporary texture to prevent WebGL erroring out.",
            "    // See https://www.html5gamedevs.com/topic/45423-why-is-this-not-allowed/",
            "    const snapshotSprite = PIXI.Sprite.from(gdjs._renderToSprite.snapshotCanvas);",
            "    pixiRenderer.render(snapshotSprite, { renderTexture: gdjs._renderToSprite.rt });",
            "    ",
            "    // Actually render",
            "    pixiRenderer.render(gdjs._renderToSprite.sprite, { renderTexture: renderTarget.texture });",
            "",
            "    snapshotSprite.destroy({ children: true, texture: true, baseTexture: true });",
            "    ",
            "} else {",
            "",
            "    const source2d = layerRenderer.getRendererObject(); // PIXI.Container",
            "    ",
            "    // Prerender to a temporary texture to prevent WebGL erroring out.",
            "    // See https://www.html5gamedevs.com/topic/45423-why-is-this-not-allowed/",
            "    pixiRenderer.render(source2d, { renderTexture: gdjs._renderToSprite.rt });",
            "",
            "    // Actually render",
            "    pixiRenderer.render(gdjs._renderToSprite.sprite, { renderTexture: renderTarget.texture });",
            "}",
            "",
            "// Ensure the original width/heigth is restored",
            "renderTarget.width = obj.getWidth();",
            "renderTarget.height = obj.getHeight();",
            ""
          ],
          "parameterObjects": "renderTarget",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "The layer to render",
          "name": "layer",
          "supplementaryInformation": "Sprite",
          "type": "layer"
        },
        {
          "description": "The sprite to render to",
          "name": "renderTarget",
          "supplementaryInformation": "Sprite",
          "type": "objectList"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Renders a scene and puts the rendered image into a sprite object.",
      "fullName": "Render a scene into a sprite",
      "functionType": "Action",
      "name": "RenderScene",
      "sentence": "Render the current scene into sprite _PARAM1_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const pixiRenderer = runtimeScene.getGame().getRenderer().getPIXIRenderer();",
            "const layerCameraZoom = runtimeScene.getLayer(\"\").getCameraZoom();",
            "const source =  runtimeScene.getRenderer().getPIXIContainer();",
            "",
            "/** @type {gdjs.SpriteRuntimeObject} */",
            "const obj = objects[0];",
            "",
            "/** @type {PIXI.Sprite} */",
            "const renderTarget = obj.getRendererObject();",
            "",
            "let height = runtimeScene.getLayer(\"\").getCameraHeight();",
            "let width = runtimeScene.getLayer(\"\").getCameraWidth();",
            "",
            "if (runtimeScene.getLayer(\"\").getCameraZ() !== 0) { // Changing the 'z' value of the camera impacts the zoom factor",
            "    height = height * layerCameraZoom;",
            "    width = width * layerCameraZoom;",
            "}",
            "",
            "height = Math.floor(height);",
            "width = Math.floor(width);",
            "",
            "// Prepare for render",
            "runtimeScene._updateLayersPreRender();",
            "runtimeScene._updateObjectsPreRender();",
            "",
            "// Ensure the target is a RenderTexture of the correct size",
            "gdjs._renderToSprite.rt.resize(width, height);",
            "if (renderTarget.texture instanceof PIXI.RenderTexture) {",
            "    renderTarget.texture.resize(width, height);",
            "} else {",
            "    renderTarget.texture = PIXI.RenderTexture.create({",
            "        width,",
            "        height,",
            "        scaleMode: runtimeScene.getGame().getScaleMode() === \"linear\"",
            "            ? PIXI.SCALE_MODES.LINEAR",
            "            : PIXI.SCALE_MODES.NEAREST",
            "    });",
            "}",
            "",
            "// Prerender to a temporary texture to prevent WebGL erroring out.",
            "// See https://www.html5gamedevs.com/topic/45423-why-is-this-not-allowed/",
            "pixiRenderer.render(source, { renderTexture: gdjs._renderToSprite.rt });",
            "",
            "// Actually render",
            "pixiRenderer.render(gdjs._renderToSprite.sprite, { renderTexture: renderTarget.texture });",
            "",
            "// Ensure the original width/heigth is restored",
            "renderTarget.width = obj.getWidth();",
            "renderTarget.height = obj.getHeight();",
            ""
          ],
          "parameterObjects": "renderTarget",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "The sprite to render to",
          "name": "renderTarget",
          "supplementaryInformation": "Sprite",
          "type": "objectList"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Renders a defined area of a scene and puts the rendered image into a sprite object.",
      "fullName": "Render an area of a scene into a sprite",
      "functionType": "Action",
      "name": "RenderSceneArea",
      "sentence": "Render the area of a current scene into Sprite: _PARAM1_, from OriginX: _PARAM2_, OriginY: _PARAM3_, with Width: _PARAM4_, Height: _PARAM5_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const source = runtimeScene.getRenderer().getPIXIContainer();",
            "source.x = eventsFunctionContext.getArgument(\"originPositionX\") * -1;",
            "source.y = eventsFunctionContext.getArgument(\"originPositionY\") * -1;",
            "const width = eventsFunctionContext.getArgument(\"areaWidth\");",
            "const height = eventsFunctionContext.getArgument(\"areaHeight\");",
            "/** @type {gdjs.SpriteRuntimeObject} */",
            "const obj = objects[0];",
            "/** @type {PIXI.Sprite} */",
            "const renderTarget = obj.getRendererObject();",
            "",
            "// Prepare for render",
            "runtimeScene._updateLayersPreRender();",
            "runtimeScene._updateObjectsPreRender();",
            "",
            "// Ensure the target is a RenderTexture of the correct size",
            "gdjs._renderToSprite.rt.resize(width, height);",
            "if (renderTarget.texture instanceof PIXI.RenderTexture) {",
            "    renderTarget.texture.resize(width, height);",
            "} else {",
            "    renderTarget.texture = PIXI.RenderTexture.create({",
            "        width,",
            "        height,",
            "        scaleMode: runtimeScene.getGame().getScaleMode() === \"linear\"",
            "            ? PIXI.SCALE_MODES.LINEAR",
            "            : PIXI.SCALE_MODES.NEAREST",
            "    });",
            "}",
            "",
            "// Prerender to a temporary texture to prevent WebGL erroring out.",
            "// See https://www.html5gamedevs.com/topic/45423-why-is-this-not-allowed/",
            "runtimeScene",
            "    .getGame()",
            "    .getRenderer()",
            "    .getPIXIRenderer()",
            "    .render(source, { renderTexture: gdjs._renderToSprite.rt });",
            "",
            "// Actually render ðŸ˜Ž",
            "runtimeScene",
            "    .getGame()",
            "    .getRenderer()",
            "    .getPIXIRenderer()",
            "    .render(gdjs._renderToSprite.sprite, { renderTexture: renderTarget.texture });",
            "",
            "// Ensure the original width/heigth is restored",
            "renderTarget.width = obj.getWidth();",
            "renderTarget.height = obj.getHeight();",
            "",
            "//Return render area to original place",
            "source.x = 0;",
            "source.y = 0;",
            ""
          ],
          "parameterObjects": "renderTarget",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "The sprite to render to",
          "name": "renderTarget",
          "supplementaryInformation": "Sprite",
          "type": "objectList"
        },
        {
          "description": "Origin X position of the render area",
          "name": "originPositionX",
          "type": "expression"
        },
        {
          "description": "Origin Y Position of the render area",
          "name": "originPositionY",
          "type": "expression"
        },
        {
          "description": "Width of the are to render",
          "name": "areaWidth",
          "type": "expression"
        },
        {
          "description": "Height of the area to render",
          "name": "areaHeight",
          "type": "expression"
        }
      ],
      "objectGroups": []
    }
  ],
  "eventsBasedBehaviors": [],
  "eventsBasedObjects": []
}